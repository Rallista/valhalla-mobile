"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.options = exports.parsers = void 0;
const babel_1 = require("prettier/plugins/babel");
/**
 * Lexical sort function for strings, meant to be used as the sort
 * function for `Array.prototype.sort`.
 *
 * @param a - First element to compare.
 * @param b - Second element to compare.
 * @returns A number indicating which element should come first.
 */
function lexicalSort(a, b) {
    if (a > b) {
        return 1;
    }
    if (a < b) {
        return -1;
    }
    return 0;
}
const integerPrefixRegex = /^(-?\d+)/u;
/**
 * Numeric sort function for strings, meant to be used as the sort
 * function for `Array.prototype.sort`.
 *
 * The number prefixing each string (if any) is sorted numerically.
 * Otherwise the string is sorted Lexically.
 *
 * @param a - First element to compare.
 * @param b - Second element to compare.
 * @returns A number indicating which element should come first.
 */
function numericSort(a, b) {
    const aPrefixResult = a.match(integerPrefixRegex);
    const bPrefixResult = b.match(integerPrefixRegex);
    if (aPrefixResult !== null && bPrefixResult !== null) {
        // Guaranteed to be non-null because we checked for `null`, and because there is a capture
        // group in the regex
        /* eslint-disable @typescript-eslint/no-non-null-assertion */
        const rawAPrefix = aPrefixResult[1];
        const rawBPrefix = bPrefixResult[1];
        /* eslint-enable @typescript-eslint/no-non-null-assertion */
        const aPrefix = parseInt(rawAPrefix, 10);
        const bPrefix = parseInt(rawBPrefix, 10);
        const difference = aPrefix - bPrefix;
        if (difference !== 0) {
            return difference;
        }
    }
    return String(a) > String(b) ? 1 : -1;
}
/**
 * Reverse a sort function. This is meant to wrap functions meant to be
 * used as the sort function for `Array.prototype.sort`.
 *
 * @param sortFunction - The sort function to reverse.
 * @returns A reversed sort function.
 */
function reverseSort(sortFunction) {
    return (a, b) => {
        return -1 * sortFunction(a, b);
    };
}
/**
 * Make a sort function case-insensitive. This is meant to wrap
 * functions meant to be used as the sort function for
 * `Array.prototype.sort`.
 *
 * @param sortFunction - The sort function to make case-insensitive.
 * @returns A case-insensitive sort function.
 */
function caseInsensitiveSort(sortFunction) {
    return (a, b) => {
        return sortFunction(a.toLowerCase(), b.toLowerCase()) || sortFunction(a, b);
    };
}
/**
 * Skip sort function, meant to be used as the sort
 * function for `Array.prototype.sort`.
 *
 * @param _a - First element to compare.
 * @param _b - Second element to compare.
 * @returns A number indicating which element should come first.
 */
function noneSort(_a, _b) {
    return 0;
}
/**
 * A mapping of category sort algorithms to sort functions.
 */
const categorySortFunctions = {
    caseInsensitiveLexical: caseInsensitiveSort(lexicalSort),
    caseInsensitiveNumeric: caseInsensitiveSort(numericSort),
    caseInsensitiveReverseLexical: caseInsensitiveSort(reverseSort(lexicalSort)),
    caseInsensitiveReverseNumeric: caseInsensitiveSort(reverseSort(numericSort)),
    lexical: lexicalSort,
    numeric: numericSort,
    reverseLexical: reverseSort(lexicalSort),
    reverseNumeric: reverseSort(numericSort),
    none: noneSort,
};
/**
 * A list of all allowed category sort values.
 */
const allowedCategorySortValues = [null, ...Object.keys(categorySortFunctions)];
/**
 * Asserts that the given AST properties only contain 'ObjectProperty' entries.
 * The other two types are not found in JSON files.
 *
 * @param properties - The properties to check.
 * @throws Throws an error if unexpected property types are found.
 */
function assertObjectPropertyTypes(properties) {
    const invalidProperty = properties.find((property) => property.type !== 'ObjectProperty');
    /* c8 ignore start */
    if (invalidProperty !== undefined) {
        throw new Error(`Property type not supported: ${invalidProperty.type}`);
    }
    /* c8 ignore stop */
}
/**
 * Asserts that the given AST object property is a string literal. This should
 * be the only type of key found in JSON files.
 *
 * @param objectPropertyKey - The key to check.
 * @throws Throws an error if the key has an unexpected type.
 */
function assertObjectPropertyKeyType(objectPropertyKey) {
    /* c8 ignore start */
    if (objectPropertyKey.type !== 'StringLiteral') {
        throw new Error(`Object property key type not supported: ${objectPropertyKey.type}`);
    }
    /* c8 ignore stop */
}
/**
 * Determins whether the given object property value is an array or object.
 *
 * @param value - The ObjectProperty value to check.
 * @returns True if the value is an array or object, false otherwise.
 */
function valueIsArrayOrObjectExpression(value) {
    return ['ObjectExpression', 'ArrayExpression'].includes(value.type);
}
/**
 * Sort properties of JavaScript objects within an AST.
 *
 * @param ast - The AST to sort.
 * @param recursive - Whether to sort the object recursively or not.
 * @param sortCompareFunction - A custom sort function.
 * @returns The sorted object.
 */
function sortAst(ast, recursive, sortCompareFunction) {
    if (ast.type === 'ArrayExpression' && recursive) {
        ast.elements = ast.elements.map((element) => {
            if (element === null || element.type === 'NullLiteral') {
                return element;
            } /* c8 ignore start */
            else if (element.type === 'SpreadElement') {
                throw new Error('Unreachable; SpreadElement is not allowed in JSON');
            }
            /* c8 ignore stop */
            return sortAst(element, recursive, sortCompareFunction);
        });
    }
    else if (ast.type === 'ObjectExpression') {
        const { properties } = ast;
        assertObjectPropertyTypes(properties);
        const sortedProperties = properties.sort((propertyA, propertyB) => {
            assertObjectPropertyKeyType(propertyA.key);
            assertObjectPropertyKeyType(propertyB.key);
            return sortCompareFunction(propertyA.key.value, propertyB.key.value);
        });
        if (recursive) {
            const recursivelySortedProperties = sortedProperties.map((property) => {
                const { value } = property;
                if (valueIsArrayOrObjectExpression(value)) {
                    property.value = sortAst(value, recursive, sortCompareFunction);
                }
                return property;
            });
            ast.properties = recursivelySortedProperties;
        }
        else {
            ast.properties = sortedProperties;
        }
    }
    return ast;
}
/**
 * Parse JSON sort options from Prettier options.
 *
 * @param prettierOptions - Prettier options.
 * @returns JSON sort options.
 */
function parseOptions(prettierOptions) {
    // Unreachable, validated before here by Prettier
    /* c8 ignore start */
    if (typeof prettierOptions.jsonRecursiveSort !== 'boolean') {
        throw new Error(`Invalid 'jsonRecursiveSort' option; expected boolean, got '${typeof prettierOptions.jsonRecursiveSort}'`);
    }
    /* c8 ignore stop */
    const parsedJsonSortOptions = {
        jsonRecursiveSort: prettierOptions.jsonRecursiveSort,
    };
    if (prettierOptions.jsonSortOrder !== undefined) {
        const rawJsonSortOrder = prettierOptions.jsonSortOrder;
        // Unreachable, validated before here by Prettier
        /* c8 ignore start */
        if (typeof rawJsonSortOrder !== 'string') {
            throw new Error(`Invalid 'jsonSortOrder' option; expected string, got '${typeof prettierOptions.rawJsonSortOrder}'`);
        }
        /* c8 ignore stop */
        let parsedJsonSortOrder;
        try {
            parsedJsonSortOrder = JSON.parse(rawJsonSortOrder);
        }
        catch (error) {
            // @ts-expect-error Error cause property not yet supported by '@types/node' (see https://github.com/DefinitelyTyped/DefinitelyTyped/pull/61827)
            throw new Error(`Failed to parse sort order option as JSON`, {
                cause: error,
            });
        }
        if (Array.isArray(parsedJsonSortOrder) ||
            typeof parsedJsonSortOrder !== 'object') {
            throw new Error(`Invalid custom sort order; must be an object`);
        }
        for (const categorySort of Object.values(parsedJsonSortOrder)) {
            if ((categorySort !== null && typeof categorySort !== 'string') ||
                !allowedCategorySortValues.includes(categorySort)) {
                throw new Error(`Invalid custom sort entry: value must be one of '${String(allowedCategorySortValues.map(String))}', got '${String(categorySort)}'`);
            }
        }
        parsedJsonSortOptions.jsonSortOrder = parsedJsonSortOrder;
    }
    return parsedJsonSortOptions;
}
/**
 * Apply default sort options.
 *
 * @param options - JSON sort options as configured.
 * @returns JSON sort options with defaults applied.
 */
function applyDefaultOptions(options) {
    const { jsonRecursiveSort, jsonSortOrder } = options;
    return {
        jsonRecursiveSort, // Default already applied by Prettier
        jsonSortOrder: jsonSortOrder !== null && jsonSortOrder !== void 0 ? jsonSortOrder : {},
    };
}
/**
 * Create sort compare function from a custom JSON sort order configuration.
 *
 * @param jsonSortOrder - JSON sort order configuration.
 * @returns A sorting function for comparing Object keys.
 */
function createSortCompareFunction(jsonSortOrder) {
    const evaluateSortEntry = (value, entry) => {
        const regexRegex = /^\/(.+)\/([imsu]*)$/u;
        const regexResult = entry.match(regexRegex);
        if (regexResult) {
            const [, regexSpec, flags] = regexResult;
            /* c8 ignore start */
            if (!regexSpec) {
                // The RegExp specifies that this capture group be non-empty, so this is unreachable
                throw new Error('Unreachable, empty RegExp specification found');
            }
            /* c8 ignore stop */
            const regex = new RegExp(regexSpec, flags);
            return Boolean(value.match(regex));
        }
        return value === entry;
    };
    const sortEntries = Object.keys(jsonSortOrder);
    return (a, b) => {
        const aIndex = sortEntries.findIndex(evaluateSortEntry.bind(null, a));
        const bIndex = sortEntries.findIndex(evaluateSortEntry.bind(null, b));
        if (aIndex === -1 && bIndex === -1) {
            return lexicalSort(a, b);
        }
        else if (bIndex === -1) {
            return -1;
        }
        else if (aIndex === -1) {
            return 1;
        }
        else if (aIndex === bIndex) {
            const sortEntry = sortEntries[aIndex];
            /* c8 ignore start */
            if (sortEntry === undefined) {
                // Sort entry guaranteed to be non-null because index was found
                throw new Error('Unreachable, undefined sort entry');
            }
            /* c8 ignore stop */
            const categorySort = jsonSortOrder[sortEntry];
            /* c8 ignore start */
            if (categorySort === undefined) {
                // Guaranteed to be defined because `sortEntry` is derived from `Object.keys`
                throw new Error('Unreachable, undefined category sort entry');
            }
            /* c8 ignore stop */
            const categorySortFunction = categorySort === null
                ? lexicalSort
                : categorySortFunctions[categorySort];
            return categorySortFunction(a, b);
        }
        return aIndex - bIndex;
    };
}
/**
 * Create a JSON sorting parser based upon the specified Prettier parser.
 *
 * @param parser - The Prettier JSON parser to base the sorting on.
 * @returns The JSON sorting parser.
 */
function createParser(parser) {
    return async (text, prettierOptions) => {
        const { jsonRecursiveSort, jsonSortOrder } = applyDefaultOptions(parseOptions(prettierOptions));
        const jsonRootAst = await babel_1.parsers[parser].parse(text, prettierOptions);
        // The Prettier JSON parser wraps the AST in a 'JsonRoot' node
        // This ast variable is the real document root
        const ast = jsonRootAst.node;
        // Only objects are intended to be sorted by this plugin
        // Arrays are considered only in recursive mode, so that we
        // can get to nested objected.
        if (!(ast.type === 'ObjectExpression' ||
            (ast.type === 'ArrayExpression' && jsonRecursiveSort))) {
            return jsonRootAst;
        }
        const sortCompareFunction = createSortCompareFunction(jsonSortOrder);
        const sortedAst = sortAst(ast, jsonRecursiveSort, sortCompareFunction);
        return Object.assign(Object.assign({}, jsonRootAst), { node: sortedAst });
    };
}
exports.parsers = {
    json: Object.assign(Object.assign({}, babel_1.parsers.json), { parse: createParser('json') }),
};
exports.options = {
    jsonRecursiveSort: {
        category: 'json-sort',
        default: false,
        description: 'Sort JSON files recursively, including any nested properties',
        since: '0.0.2',
        type: 'boolean',
    },
    jsonSortOrder: {
        category: 'json-sort',
        description: 'A JSON string specifying a custom sort order',
        since: '0.0.4',
        type: 'string',
    },
};
//# sourceMappingURL=index.js.map