{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ArrayExpression,\n  Expression,\n  ObjectExpression,\n  ObjectProperty,\n  NullLiteral,\n  SpreadElement,\n  StringLiteral,\n  ObjectMethod,\n} from '@babel/types';\nimport type { ParserOptions } from 'prettier';\nimport { parsers as babelParsers } from 'prettier/plugins/babel';\n\n/**\n * Lexical sort function for strings, meant to be used as the sort\n * function for `Array.prototype.sort`.\n *\n * @param a - First element to compare.\n * @param b - Second element to compare.\n * @returns A number indicating which element should come first.\n */\nfunction lexicalSort(a: string, b: string): number {\n  if (a > b) {\n    return 1;\n  }\n  if (a < b) {\n    return -1;\n  }\n  return 0;\n}\n\nconst integerPrefixRegex = /^(-?\\d+)/u;\n\n/**\n * Numeric sort function for strings, meant to be used as the sort\n * function for `Array.prototype.sort`.\n *\n * The number prefixing each string (if any) is sorted numerically.\n * Otherwise the string is sorted Lexically.\n *\n * @param a - First element to compare.\n * @param b - Second element to compare.\n * @returns A number indicating which element should come first.\n */\nfunction numericSort(a: string, b: string): number {\n  const aPrefixResult = a.match(integerPrefixRegex);\n  const bPrefixResult = b.match(integerPrefixRegex);\n  if (aPrefixResult !== null && bPrefixResult !== null) {\n    // Guaranteed to be non-null because we checked for `null`, and because there is a capture\n    // group in the regex\n    /* eslint-disable @typescript-eslint/no-non-null-assertion */\n    const rawAPrefix = aPrefixResult[1]!;\n    const rawBPrefix = bPrefixResult[1]!;\n    /* eslint-enable @typescript-eslint/no-non-null-assertion */\n    const aPrefix = parseInt(rawAPrefix, 10);\n    const bPrefix = parseInt(rawBPrefix, 10);\n    const difference = aPrefix - bPrefix;\n    if (difference !== 0) {\n      return difference;\n    }\n  }\n  return String(a) > String(b) ? 1 : -1;\n}\n\n/**\n * Reverse a sort function. This is meant to wrap functions meant to be\n * used as the sort function for `Array.prototype.sort`.\n *\n * @param sortFunction - The sort function to reverse.\n * @returns A reversed sort function.\n */\nfunction reverseSort(\n  sortFunction: (a: string, b: string) => number,\n): (a: string, b: string) => number {\n  return (a: string, b: string) => {\n    return -1 * sortFunction(a, b);\n  };\n}\n\n/**\n * Make a sort function case-insensitive. This is meant to wrap\n * functions meant to be used as the sort function for\n * `Array.prototype.sort`.\n *\n * @param sortFunction - The sort function to make case-insensitive.\n * @returns A case-insensitive sort function.\n */\nfunction caseInsensitiveSort(\n  sortFunction: (a: string, b: string) => number,\n): (a: string, b: string) => number {\n  return (a: string, b: string) => {\n    return sortFunction(a.toLowerCase(), b.toLowerCase()) || sortFunction(a, b);\n  };\n}\n\n/**\n * Skip sort function, meant to be used as the sort\n * function for `Array.prototype.sort`.\n *\n * @param _a - First element to compare.\n * @param _b - Second element to compare.\n * @returns A number indicating which element should come first.\n */\nfunction noneSort(_a: string, _b: string): number {\n  return 0;\n}\n\n/**\n * Sorting algorithms for categories in a custom sort order definition.\n */\nexport type CategorySort =\n  | 'caseInsensitiveLexical'\n  | 'caseInsensitiveNumeric'\n  | 'caseInsensitiveReverseLexical'\n  | 'caseInsensitiveReverseNumeric'\n  | 'lexical'\n  | 'numeric'\n  | 'reverseLexical'\n  | 'reverseNumeric'\n  | 'none';\n\n/**\n * A mapping of category sort algorithms to sort functions.\n */\nconst categorySortFunctions: Record<\n  CategorySort,\n  (a: string, b: string) => number\n> = {\n  caseInsensitiveLexical: caseInsensitiveSort(lexicalSort),\n  caseInsensitiveNumeric: caseInsensitiveSort(numericSort),\n  caseInsensitiveReverseLexical: caseInsensitiveSort(reverseSort(lexicalSort)),\n  caseInsensitiveReverseNumeric: caseInsensitiveSort(reverseSort(numericSort)),\n  lexical: lexicalSort,\n  numeric: numericSort,\n  reverseLexical: reverseSort(lexicalSort),\n  reverseNumeric: reverseSort(numericSort),\n  none: noneSort,\n};\n\n/**\n * A list of all allowed category sort values.\n */\nconst allowedCategorySortValues = [null, ...Object.keys(categorySortFunctions)];\n\n/**\n * Asserts that the given AST properties only contain 'ObjectProperty' entries.\n * The other two types are not found in JSON files.\n *\n * @param properties - The properties to check.\n * @throws Throws an error if unexpected property types are found.\n */\nfunction assertObjectPropertyTypes(\n  properties: (ObjectMethod | ObjectProperty | SpreadElement)[],\n): asserts properties is ObjectProperty[] {\n  const invalidProperty = properties.find(\n    (property) => property.type !== 'ObjectProperty',\n  );\n  /* c8 ignore start */\n  if (invalidProperty !== undefined) {\n    throw new Error(`Property type not supported: ${invalidProperty.type}`);\n  }\n  /* c8 ignore stop */\n}\n\n/**\n * Asserts that the given AST object property is a string literal. This should\n * be the only type of key found in JSON files.\n *\n * @param objectPropertyKey - The key to check.\n * @throws Throws an error if the key has an unexpected type.\n */\nfunction assertObjectPropertyKeyType(\n  objectPropertyKey: ObjectProperty['key'],\n): asserts objectPropertyKey is StringLiteral {\n  /* c8 ignore start */\n  if (objectPropertyKey.type !== 'StringLiteral') {\n    throw new Error(\n      `Object property key type not supported: ${objectPropertyKey.type}`,\n    );\n  }\n  /* c8 ignore stop */\n}\n\n/**\n * Determins whether the given object property value is an array or object.\n *\n * @param value - The ObjectProperty value to check.\n * @returns True if the value is an array or object, false otherwise.\n */\nfunction valueIsArrayOrObjectExpression(\n  value: ObjectProperty['value'],\n): value is ObjectExpression | ArrayExpression {\n  return ['ObjectExpression', 'ArrayExpression'].includes(value.type);\n}\n\n/**\n * Sort properties of JavaScript objects within an AST.\n *\n * @param ast - The AST to sort.\n * @param recursive - Whether to sort the object recursively or not.\n * @param sortCompareFunction - A custom sort function.\n * @returns The sorted object.\n */\nfunction sortAst(\n  ast: Expression,\n  recursive: boolean,\n  sortCompareFunction: (a: string, b: string) => number,\n): Expression {\n  if (ast.type === 'ArrayExpression' && recursive) {\n    ast.elements = ast.elements.map(\n      (element: null | NullLiteral | Expression | SpreadElement) => {\n        if (element === null || element.type === 'NullLiteral') {\n          return element;\n        } /* c8 ignore start */ else if (element.type === 'SpreadElement') {\n          throw new Error('Unreachable; SpreadElement is not allowed in JSON');\n        }\n        /* c8 ignore stop */\n        return sortAst(element, recursive, sortCompareFunction);\n      },\n    );\n  } else if (ast.type === 'ObjectExpression') {\n    const { properties } = ast;\n    assertObjectPropertyTypes(properties);\n    const sortedProperties = properties.sort(\n      (propertyA: ObjectProperty, propertyB: ObjectProperty) => {\n        assertObjectPropertyKeyType(propertyA.key);\n        assertObjectPropertyKeyType(propertyB.key);\n        return sortCompareFunction(propertyA.key.value, propertyB.key.value);\n      },\n    );\n\n    if (recursive) {\n      const recursivelySortedProperties = sortedProperties.map(\n        (property: ObjectProperty) => {\n          const { value } = property;\n          if (valueIsArrayOrObjectExpression(value)) {\n            property.value = sortAst(value, recursive, sortCompareFunction);\n          }\n          return property;\n        },\n      );\n      ast.properties = recursivelySortedProperties;\n    } else {\n      ast.properties = sortedProperties;\n    }\n  }\n  return ast;\n}\n\n/**\n * JSON sorting options. See README for details.\n */\nexport type SortJsonOptions = {\n  jsonRecursiveSort?: boolean;\n  jsonSortOrder?: Record<string, CategorySort | null>;\n};\n\n/**\n * JSON sorting options after they have been processed by Prettier.\n *\n * Defaults set in the 'options' export have been applied by this point.\n */\ntype ProcessedSortJsonOptions = Omit<SortJsonOptions, 'jsonRecursiveSort'> &\n  Required<Pick<SortJsonOptions, 'jsonRecursiveSort'>>;\n\n/**\n * Parse JSON sort options from Prettier options.\n *\n * @param prettierOptions - Prettier options.\n * @returns JSON sort options.\n */\nfunction parseOptions(\n  prettierOptions: ParserOptions,\n): ProcessedSortJsonOptions {\n  // Unreachable, validated before here by Prettier\n  /* c8 ignore start */\n  if (typeof prettierOptions.jsonRecursiveSort !== 'boolean') {\n    throw new Error(\n      `Invalid 'jsonRecursiveSort' option; expected boolean, got '${typeof prettierOptions.jsonRecursiveSort}'`,\n    );\n  }\n  /* c8 ignore stop */\n  const parsedJsonSortOptions: ProcessedSortJsonOptions = {\n    jsonRecursiveSort: prettierOptions.jsonRecursiveSort,\n  };\n\n  if (prettierOptions.jsonSortOrder !== undefined) {\n    const rawJsonSortOrder = prettierOptions.jsonSortOrder;\n    // Unreachable, validated before here by Prettier\n    /* c8 ignore start */\n    if (typeof rawJsonSortOrder !== 'string') {\n      throw new Error(\n        `Invalid 'jsonSortOrder' option; expected string, got '${typeof prettierOptions.rawJsonSortOrder}'`,\n      );\n    }\n    /* c8 ignore stop */\n\n    let parsedJsonSortOrder;\n    try {\n      parsedJsonSortOrder = JSON.parse(rawJsonSortOrder);\n    } catch (error) {\n      // @ts-expect-error Error cause property not yet supported by '@types/node' (see https://github.com/DefinitelyTyped/DefinitelyTyped/pull/61827)\n      throw new Error(`Failed to parse sort order option as JSON`, {\n        cause: error,\n      });\n    }\n\n    if (\n      Array.isArray(parsedJsonSortOrder) ||\n      typeof parsedJsonSortOrder !== 'object'\n    ) {\n      throw new Error(`Invalid custom sort order; must be an object`);\n    }\n\n    for (const categorySort of Object.values(parsedJsonSortOrder)) {\n      if (\n        (categorySort !== null && typeof categorySort !== 'string') ||\n        !allowedCategorySortValues.includes(categorySort)\n      ) {\n        throw new Error(\n          `Invalid custom sort entry: value must be one of '${String(\n            allowedCategorySortValues.map(String),\n          )}', got '${String(categorySort)}'`,\n        );\n      }\n    }\n\n    parsedJsonSortOptions.jsonSortOrder = parsedJsonSortOrder;\n  }\n\n  return parsedJsonSortOptions;\n}\n\n/**\n * Apply default sort options.\n *\n * @param options - JSON sort options as configured.\n * @returns JSON sort options with defaults applied.\n */\nfunction applyDefaultOptions(\n  options: ProcessedSortJsonOptions,\n): Required<ProcessedSortJsonOptions> {\n  const { jsonRecursiveSort, jsonSortOrder } = options;\n\n  return {\n    jsonRecursiveSort, // Default already applied by Prettier\n    jsonSortOrder: jsonSortOrder ?? {},\n  };\n}\n\n/**\n * Create sort compare function from a custom JSON sort order configuration.\n *\n * @param jsonSortOrder - JSON sort order configuration.\n * @returns A sorting function for comparing Object keys.\n */\nfunction createSortCompareFunction(\n  jsonSortOrder: Record<string, CategorySort | null>,\n): (a: string, b: string) => number {\n  const evaluateSortEntry = (value: string, entry: string): boolean => {\n    const regexRegex = /^\\/(.+)\\/([imsu]*)$/u;\n    const regexResult = entry.match(regexRegex);\n    if (regexResult) {\n      const [, regexSpec, flags]: string[] = regexResult;\n      /* c8 ignore start */\n      if (!regexSpec) {\n        // The RegExp specifies that this capture group be non-empty, so this is unreachable\n        throw new Error('Unreachable, empty RegExp specification found');\n      }\n      /* c8 ignore stop */\n      const regex = new RegExp(regexSpec, flags);\n      return Boolean(value.match(regex));\n    }\n    return value === entry;\n  };\n\n  const sortEntries = Object.keys(jsonSortOrder);\n\n  return (a: string, b: string): number => {\n    const aIndex = sortEntries.findIndex(evaluateSortEntry.bind(null, a));\n    const bIndex = sortEntries.findIndex(evaluateSortEntry.bind(null, b));\n\n    if (aIndex === -1 && bIndex === -1) {\n      return lexicalSort(a, b);\n    } else if (bIndex === -1) {\n      return -1;\n    } else if (aIndex === -1) {\n      return 1;\n    } else if (aIndex === bIndex) {\n      const sortEntry = sortEntries[aIndex];\n      /* c8 ignore start */\n      if (sortEntry === undefined) {\n        // Sort entry guaranteed to be non-null because index was found\n        throw new Error('Unreachable, undefined sort entry');\n      }\n      /* c8 ignore stop */\n      const categorySort = jsonSortOrder[sortEntry];\n      /* c8 ignore start */\n      if (categorySort === undefined) {\n        // Guaranteed to be defined because `sortEntry` is derived from `Object.keys`\n        throw new Error('Unreachable, undefined category sort entry');\n      }\n      /* c8 ignore stop */\n      const categorySortFunction =\n        categorySort === null\n          ? lexicalSort\n          : categorySortFunctions[categorySort];\n      return categorySortFunction(a, b);\n    }\n    return aIndex - bIndex;\n  };\n}\n\n/**\n * Prettier JSON parsers.\n */\ntype JsonParser = 'json';\n\n/**\n * Create a JSON sorting parser based upon the specified Prettier parser.\n *\n * @param parser - The Prettier JSON parser to base the sorting on.\n * @returns The JSON sorting parser.\n */\nfunction createParser(\n  parser: JsonParser,\n): (text: string, options: ParserOptions) => Promise<any> {\n  return async (text: string, prettierOptions: ParserOptions): Promise<any> => {\n    const { jsonRecursiveSort, jsonSortOrder } = applyDefaultOptions(\n      parseOptions(prettierOptions),\n    );\n\n    const jsonRootAst = await babelParsers[parser].parse(text, prettierOptions);\n\n    // The Prettier JSON parser wraps the AST in a 'JsonRoot' node\n    // This ast variable is the real document root\n    const ast = jsonRootAst.node;\n\n    // Only objects are intended to be sorted by this plugin\n    // Arrays are considered only in recursive mode, so that we\n    // can get to nested objected.\n    if (\n      !(\n        ast.type === 'ObjectExpression' ||\n        (ast.type === 'ArrayExpression' && jsonRecursiveSort)\n      )\n    ) {\n      return jsonRootAst;\n    }\n\n    const sortCompareFunction = createSortCompareFunction(jsonSortOrder);\n    const sortedAst = sortAst(ast, jsonRecursiveSort, sortCompareFunction);\n\n    return {\n      ...jsonRootAst,\n      node: sortedAst,\n    };\n  };\n}\n\nexport const parsers = {\n  json: {\n    ...babelParsers.json,\n    parse: createParser('json'),\n  },\n};\n\nexport const options = {\n  jsonRecursiveSort: {\n    category: 'json-sort',\n    default: false,\n    description: 'Sort JSON files recursively, including any nested properties',\n    since: '0.0.2',\n    type: 'boolean' as const,\n  },\n  jsonSortOrder: {\n    category: 'json-sort',\n    description: 'A JSON string specifying a custom sort order',\n    since: '0.0.4',\n    type: 'string' as const,\n  },\n};\n\n/*\n * Augument Prettierâ€™s `Options` interface with JSON sorting options.\n */\ndeclare module 'prettier' {\n  /* eslint-disable-next-line @typescript-eslint/consistent-type-definitions */\n  interface Options {\n    /**\n     * Sort JSON objects recursively, including all nested objects. This also sorts objects within JSON arrays.\n     *\n     * @default false\n     */\n    jsonRecursiveSort?: boolean | undefined;\n\n    /**\n     * Use a custom sort order. This is specified as a JSON string containing a set of sorting rules.\n     */\n    jsonSortOrder?: string | undefined;\n  }\n}\n"]}