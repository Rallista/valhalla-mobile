/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package Models

import Models.CostingOptions
import Models.DirectionsOptions
import Models.MapMatchCostingModel
import Models.MapMatchWaypoint

import com.squareup.moshi.Json
import com.squareup.moshi.JsonClass

/**
 * 
 *
 * @param costing 
 * @param id An identifier to disambiguate requests (echoed by the server).
 * @param shape REQUIRED if `encoded_polyline` is not present. Note that `break` type locations are only supported when `shape_match` is set to `map_match`.
 * @param encodedPolyline REQUIRED if `shape` is not present. An encoded polyline (https://developers.google.com/maps/documentation/utilities/polylinealgorithm). Note that the polyline must be encoded with 6 digits of precision rather than the usual 5.
 * @param costingOptions 
 * @param shapeMatch Three snapping modes provide some control over how the map matching occurs. `edge_walk` is fast, but requires extremely precise data that matches the route graph almost perfectly. `map_snap` can handle significantly noisier data, but is very expensive. `walk_or_snap`, the default, tries to use edge walking first and falls back to map matching if edge walking fails. In general, you should not need to change this parameter unless you want to trace a multi-leg route with multiple `break` locations in the `shape`.
 * @param directionsOptions 
 */


data class BaseTraceRequest (

    @Json(name = "costing")
    val costing: MapMatchCostingModel,

    /* An identifier to disambiguate requests (echoed by the server). */
    @Json(name = "id")
    val id: kotlin.String? = null,

    /* REQUIRED if `encoded_polyline` is not present. Note that `break` type locations are only supported when `shape_match` is set to `map_match`. */
    @Json(name = "shape")
    val shape: kotlin.collections.List<MapMatchWaypoint>? = null,

    /* REQUIRED if `shape` is not present. An encoded polyline (https://developers.google.com/maps/documentation/utilities/polylinealgorithm). Note that the polyline must be encoded with 6 digits of precision rather than the usual 5. */
    @Json(name = "encoded_polyline")
    val encodedPolyline: kotlin.String? = null,

    @Json(name = "costing_options")
    val costingOptions: CostingOptions? = null,

    /* Three snapping modes provide some control over how the map matching occurs. `edge_walk` is fast, but requires extremely precise data that matches the route graph almost perfectly. `map_snap` can handle significantly noisier data, but is very expensive. `walk_or_snap`, the default, tries to use edge walking first and falls back to map matching if edge walking fails. In general, you should not need to change this parameter unless you want to trace a multi-leg route with multiple `break` locations in the `shape`. */
    @Json(name = "shape_match")
    val shapeMatch: BaseTraceRequest.ShapeMatch? = null,

    @Json(name = "directions_options")
    val directionsOptions: DirectionsOptions? = null

) {

    /**
     * Three snapping modes provide some control over how the map matching occurs. `edge_walk` is fast, but requires extremely precise data that matches the route graph almost perfectly. `map_snap` can handle significantly noisier data, but is very expensive. `walk_or_snap`, the default, tries to use edge walking first and falls back to map matching if edge walking fails. In general, you should not need to change this parameter unless you want to trace a multi-leg route with multiple `break` locations in the `shape`.
     *
     * Values: edgeWalk,mapSnap,walkOrSnap
     */
    @JsonClass(generateAdapter = false)
    enum class ShapeMatch(val value: kotlin.String) {
        @Json(name = "edge_walk") edgeWalk("edge_walk"),
        @Json(name = "map_snap") mapSnap("map_snap"),
        @Json(name = "walk_or_snap") walkOrSnap("walk_or_snap");
    }
}

