/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package Models

import Models.Contour
import Models.Coordinate
import Models.CostingOptions
import Models.IsochroneCostingModel

import com.squareup.moshi.Json
import com.squareup.moshi.JsonClass

/**
 * 
 *
 * @param locations 
 * @param costing 
 * @param contours 
 * @param id An identifier to disambiguate requests (echoed by the server).
 * @param costingOptions 
 * @param polygons If true, the generated GeoJSON will use polygons. The default is to use LineStrings. Polygon output makes it easier to render overlapping areas in some visualization tools (such as MapLibre renderers).
 * @param denoise A value in the range [0, 1] which will be used to smooth out or remove smaller contours. A value of 1 will only return the largest contour for a given time value. A value of 0.5 drops any contours that are less than half the area of the largest contour in the set of contours for that same time value.
 * @param generalize The value in meters to be used as a tolerance for Douglas-Peucker generalization.
 * @param showLocations If true, then the output GeoJSON will include the input locations as two MultiPoint features: one for the exact input coordinates, and a second for the route network node location that the point was snapped to.
 */


data class IsochroneRequest (

    @Json(name = "locations")
    val locations: kotlin.collections.List<Coordinate>,

    @Json(name = "costing")
    val costing: IsochroneCostingModel,

    @Json(name = "contours")
    val contours: kotlin.collections.List<Contour>,

    /* An identifier to disambiguate requests (echoed by the server). */
    @Json(name = "id")
    val id: kotlin.String? = null,

    @Json(name = "costing_options")
    val costingOptions: CostingOptions? = null,

    /* If true, the generated GeoJSON will use polygons. The default is to use LineStrings. Polygon output makes it easier to render overlapping areas in some visualization tools (such as MapLibre renderers). */
    @Json(name = "polygons")
    val polygons: kotlin.Boolean? = false,

    /* A value in the range [0, 1] which will be used to smooth out or remove smaller contours. A value of 1 will only return the largest contour for a given time value. A value of 0.5 drops any contours that are less than half the area of the largest contour in the set of contours for that same time value. */
    @Json(name = "denoise")
    val denoise: kotlin.Double? = 1.0,

    /* The value in meters to be used as a tolerance for Douglas-Peucker generalization. */
    @Json(name = "generalize")
    val generalize: kotlin.Double? = 200.0,

    /* If true, then the output GeoJSON will include the input locations as two MultiPoint features: one for the exact input coordinates, and a second for the route network node location that the point was snapped to. */
    @Json(name = "show_locations")
    val showLocations: kotlin.Boolean? = false

)

