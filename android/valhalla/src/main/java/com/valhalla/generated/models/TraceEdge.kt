/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package Models

import Models.EdgeSign
import Models.EdgeUse
import Models.EndNode
import Models.RoadClass
import Models.TravelMode
import Models.Traversability

import com.squareup.moshi.Json
import com.squareup.moshi.JsonClass

/**
 * 
 *
 * @param names The name(s) of the road at this edge, if any.
 * @param length The length of this edge in `units`.
 * @param speed The speed of this edge in `units`/hr, in terms of average/free-flow speed for routing purposes. This is affected by any number of factors such as the road service, vehicle type, etc. and not just the posted speed limits.
 * @param roadClass 
 * @param beginHeading The direction at the beginning of an edge. The units are degrees clockwise from north.
 * @param endHeading The direction at the end of an edge. The units are degrees clockwise from north.
 * @param beginShapeIndex Index into the list of shape points for the start of the edge.
 * @param endShapeIndex Index into the list of shape points for the end of the edge.
 * @param traversability 
 * @param use 
 * @param toll True if the edge has a toll.
 * @param unpaved True if the edge has rough payment.
 * @param tunnel True if the edge has a tunnel.
 * @param bridge True if the edge has a bridge.
 * @param roundabout True if the edge has a roundabout.
 * @param internalIntersection True if the edge has an internal intersection.
 * @param driveOnRight True if the edge is in an area where you must drive on the right side of the road.
 * @param surface The type of surface for the edge.
 * @param sign 
 * @param travelMode 
 * @param vehicleType 
 * @param pedestrianType 
 * @param bicycleType 
 * @param transitType 
 * @param id 
 * @param wayId The way identifier of the edge in OSM.
 * @param weightedGrade The weighted grade factor. Valhalla manufactures a weighted grade from elevation data. It is a measure used for hill avoidance in routing - sort of a relative energy use along an edge. But since an edge in Valhalla can possibly go up and down over several hills it might not equate to what you would normally think of as grade.
 * @param maxUpwardGrade The maximum upward slope. A value of 32768 indicates no elevation data is available for this edge.
 * @param maxDownwardGrade The maximum downward slope. A value of 32768 indicates no elevation data is available for this edge.
 * @param meanElevation The mean elevation along the edge. Units are meters by default. If the `units` are specified as miles, then the mean elevation is returned in feet. A value of 32768 indicates no elevation data is available for this edge.
 * @param laneCount The number of lanes for this edge.
 * @param cycleLane The type of cycle lane (if any) along this edge.
 * @param bicycleNetwork The type of bicycle network, if any. This is an integer comprised of constants bitwise or'd together. For example, a route that's part of both a local and mountain network would have a value of 12. 1 - National 2 - Regional 4 - Local 8 - Mountain
 * @param sacScale The difficulty of the hiking trail according to the SAC scale. 0 - No Sac Scale 1 - Hiking 2 - Mountain hiking 3 - Demanding mountain hiking 4 - Alpine hiking 5 - Demanding alpine hiking 6 - Difficult alpine hiking
 * @param sidewalk 
 * @param density 
 * @param speedLimit The speed limit along the edge measured in `units`/hr. This may be either an integer or the string \"unlimited\" if speed limit data is available. If absent, there is no speed limit data available.
 * @param truckSpeed The truck speed of this edge in `units`/hr, in terms of average/free-flow speed for routing purposes. This is affected by any number of factors such as the road service, vehicle type, etc. and not just the posted speed limits.
 * @param truckRoute True if the edge is part of a truck route/network.
 * @param endNode 
 */


data class TraceEdge (

    /* The name(s) of the road at this edge, if any. */
    @Json(name = "names")
    val names: kotlin.collections.List<kotlin.String>? = null,

    /* The length of this edge in `units`. */
    @Json(name = "length")
    val length: kotlin.Double? = null,

    /* The speed of this edge in `units`/hr, in terms of average/free-flow speed for routing purposes. This is affected by any number of factors such as the road service, vehicle type, etc. and not just the posted speed limits. */
    @Json(name = "speed")
    val speed: kotlin.Int? = null,

    @Json(name = "road_class")
    val roadClass: RoadClass? = null,

    /* The direction at the beginning of an edge. The units are degrees clockwise from north. */
    @Json(name = "begin_heading")
    val beginHeading: kotlin.Int? = null,

    /* The direction at the end of an edge. The units are degrees clockwise from north. */
    @Json(name = "end_heading")
    val endHeading: kotlin.Int? = null,

    /* Index into the list of shape points for the start of the edge. */
    @Json(name = "begin_shape_index")
    val beginShapeIndex: kotlin.Int? = null,

    /* Index into the list of shape points for the end of the edge. */
    @Json(name = "end_shape_index")
    val endShapeIndex: kotlin.Int? = null,

    @Json(name = "traversability")
    val traversability: Traversability? = null,

    @Json(name = "use")
    val use: EdgeUse? = null,

    /* True if the edge has a toll. */
    @Json(name = "toll")
    val toll: kotlin.Boolean? = null,

    /* True if the edge has rough payment. */
    @Json(name = "unpaved")
    val unpaved: kotlin.Boolean? = null,

    /* True if the edge has a tunnel. */
    @Json(name = "tunnel")
    val tunnel: kotlin.Boolean? = null,

    /* True if the edge has a bridge. */
    @Json(name = "bridge")
    val bridge: kotlin.Boolean? = null,

    /* True if the edge has a roundabout. */
    @Json(name = "roundabout")
    val roundabout: kotlin.Boolean? = null,

    /* True if the edge has an internal intersection. */
    @Json(name = "internal_intersection")
    val internalIntersection: kotlin.Boolean? = null,

    /* True if the edge is in an area where you must drive on the right side of the road. */
    @Json(name = "drive_on_right")
    val driveOnRight: kotlin.Boolean? = null,

    /* The type of surface for the edge. */
    @Json(name = "surface")
    val surface: TraceEdge.Surface? = null,

    @Json(name = "sign")
    val sign: EdgeSign? = null,

    @Json(name = "travel_mode")
    val travelMode: TravelMode? = null,

    @Json(name = "vehicle_type")
    val vehicleType: TraceEdge.VehicleType? = null,

    @Json(name = "pedestrian_type")
    val pedestrianType: TraceEdge.PedestrianType? = null,

    @Json(name = "bicycle_type")
    val bicycleType: TraceEdge.BicycleType? = null,

    @Json(name = "transit_type")
    val transitType: TraceEdge.TransitType? = null,

    @Json(name = "id")
    val id: kotlin.Long? = null,

    /* The way identifier of the edge in OSM. */
    @Json(name = "way_id")
    val wayId: kotlin.Long? = null,

    /* The weighted grade factor. Valhalla manufactures a weighted grade from elevation data. It is a measure used for hill avoidance in routing - sort of a relative energy use along an edge. But since an edge in Valhalla can possibly go up and down over several hills it might not equate to what you would normally think of as grade. */
    @Json(name = "weighted_grade")
    val weightedGrade: kotlin.Double? = null,

    /* The maximum upward slope. A value of 32768 indicates no elevation data is available for this edge. */
    @Json(name = "max_upward_grade")
    val maxUpwardGrade: kotlin.Int? = null,

    /* The maximum downward slope. A value of 32768 indicates no elevation data is available for this edge. */
    @Json(name = "max_downward_grade")
    val maxDownwardGrade: kotlin.Int? = null,

    /* The mean elevation along the edge. Units are meters by default. If the `units` are specified as miles, then the mean elevation is returned in feet. A value of 32768 indicates no elevation data is available for this edge. */
    @Json(name = "mean_elevation")
    val meanElevation: kotlin.Int? = null,

    /* The number of lanes for this edge. */
    @Json(name = "lane_count")
    val laneCount: kotlin.Int? = null,

    /* The type of cycle lane (if any) along this edge. */
    @Json(name = "cycle_lane")
    val cycleLane: TraceEdge.CycleLane? = null,

    /* The type of bicycle network, if any. This is an integer comprised of constants bitwise or'd together. For example, a route that's part of both a local and mountain network would have a value of 12. 1 - National 2 - Regional 4 - Local 8 - Mountain */
    @Json(name = "bicycle_network")
    val bicycleNetwork: kotlin.Int? = null,

    /* The difficulty of the hiking trail according to the SAC scale. 0 - No Sac Scale 1 - Hiking 2 - Mountain hiking 3 - Demanding mountain hiking 4 - Alpine hiking 5 - Demanding alpine hiking 6 - Difficult alpine hiking */
    @Json(name = "sac_scale")
    val sacScale: kotlin.Int? = null,

    @Json(name = "sidewalk")
    val sidewalk: TraceEdge.Sidewalk? = null,

    @Json(name = "density")
    val density: kotlin.Int? = null,

    /* The speed limit along the edge measured in `units`/hr. This may be either an integer or the string \"unlimited\" if speed limit data is available. If absent, there is no speed limit data available. */
    @Json(name = "speed_limit")
    val speedLimit: kotlin.Any? = null,

    /* The truck speed of this edge in `units`/hr, in terms of average/free-flow speed for routing purposes. This is affected by any number of factors such as the road service, vehicle type, etc. and not just the posted speed limits. */
    @Json(name = "truck_speed")
    val truckSpeed: kotlin.Int? = null,

    /* True if the edge is part of a truck route/network. */
    @Json(name = "truck_route")
    val truckRoute: kotlin.Boolean? = null,

    @Json(name = "end_node")
    val endNode: EndNode? = null

) {

    /**
     * The type of surface for the edge.
     *
     * Values: pavedSmooth,paved,pavedRough,compacted,dirt,gravel,path,impassable
     */
    @JsonClass(generateAdapter = false)
    enum class Surface(val value: kotlin.String) {
        @Json(name = "paved_smooth") pavedSmooth("paved_smooth"),
        @Json(name = "paved") paved("paved"),
        @Json(name = "paved_rough") pavedRough("paved_rough"),
        @Json(name = "compacted") compacted("compacted"),
        @Json(name = "dirt") dirt("dirt"),
        @Json(name = "gravel") gravel("gravel"),
        @Json(name = "path") path("path"),
        @Json(name = "impassable") impassable("impassable");
    }
    /**
     * 
     *
     * Values: car,motorcycle,bus,tractorTrailer
     */
    @JsonClass(generateAdapter = false)
    enum class VehicleType(val value: kotlin.String) {
        @Json(name = "car") car("car"),
        @Json(name = "motorcycle") motorcycle("motorcycle"),
        @Json(name = "bus") bus("bus"),
        @Json(name = "tractor_trailer") tractorTrailer("tractor_trailer");
    }
    /**
     * 
     *
     * Values: foot,wheelchair,segway
     */
    @JsonClass(generateAdapter = false)
    enum class PedestrianType(val value: kotlin.String) {
        @Json(name = "foot") foot("foot"),
        @Json(name = "wheelchair") wheelchair("wheelchair"),
        @Json(name = "segway") segway("segway");
    }
    /**
     * 
     *
     * Values: road,cross,hybrid,mountain
     */
    @JsonClass(generateAdapter = false)
    enum class BicycleType(val value: kotlin.String) {
        @Json(name = "road") road("road"),
        @Json(name = "cross") cross("cross"),
        @Json(name = "hybrid") hybrid("hybrid"),
        @Json(name = "mountain") mountain("mountain");
    }
    /**
     * 
     *
     * Values: tram,metro,rail,bus,ferry,cableCar,gondola,funicular
     */
    @JsonClass(generateAdapter = false)
    enum class TransitType(val value: kotlin.String) {
        @Json(name = "tram") tram("tram"),
        @Json(name = "metro") metro("metro"),
        @Json(name = "rail") rail("rail"),
        @Json(name = "bus") bus("bus"),
        @Json(name = "ferry") ferry("ferry"),
        @Json(name = "cable_car") cableCar("cable_car"),
        @Json(name = "gondola") gondola("gondola"),
        @Json(name = "funicular") funicular("funicular");
    }
    /**
     * The type of cycle lane (if any) along this edge.
     *
     * Values: none,shared,dedicated,separated
     */
    @JsonClass(generateAdapter = false)
    enum class CycleLane(val value: kotlin.String) {
        @Json(name = "none") none("none"),
        @Json(name = "shared") shared("shared"),
        @Json(name = "dedicated") dedicated("dedicated"),
        @Json(name = "separated") separated("separated");
    }
    /**
     * 
     *
     * Values: left,right,both,none
     */
    @JsonClass(generateAdapter = false)
    enum class Sidewalk(val value: kotlin.String) {
        @Json(name = "left") left("left"),
        @Json(name = "right") right("right"),
        @Json(name = "both") both("both"),
        @Json(name = "none") none("none");
    }
}

