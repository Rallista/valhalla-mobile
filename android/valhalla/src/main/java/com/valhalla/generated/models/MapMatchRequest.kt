/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package Models

import Models.CostingOptions
import Models.DirectionsOptions
import Models.MapMatchCostingModel
import Models.MapMatchTraceOptions
import Models.MapMatchWaypoint

import com.squareup.moshi.Json
import com.squareup.moshi.JsonClass

/**
 * 
 *
 * @param costing 
 * @param id An identifier to disambiguate requests (echoed by the server).
 * @param shape REQUIRED if `encoded_polyline` is not present. Note that `break` type locations are only supported when `shape_match` is set to `map_match`.
 * @param encodedPolyline REQUIRED if `shape` is not present. An encoded polyline (https://developers.google.com/maps/documentation/utilities/polylinealgorithm). Note that the polyline must be encoded with 6 digits of precision rather than the usual 5.
 * @param costingOptions 
 * @param shapeMatch Three snapping modes provide some control over how the map matching occurs. `edge_walk` is fast, but requires extremely precise data that matches the route graph almost perfectly. `map_snap` can handle significantly noisier data, but is very expensive. `walk_or_snap`, the default, tries to use edge walking first and falls back to map matching if edge walking fails. In general, you should not need to change this parameter unless you want to trace a multi-leg route with multiple `break` locations in the `shape`.
 * @param directionsOptions 
 * @param beginTime The timestamp at the start of the trace. Combined with `durations`, this provides a way to include timing information for an `encoded_polyline` trace.
 * @param durations A list of durations (in seconds) between each successive pair of points in a polyline.
 * @param useTimestamps If true, the input timestamps or durations should be used when computing elapsed time for each edge along the matched path rather than the routing algorithm estimates.
 * @param traceOptions 
 * @param linearReferences If true, the response will include a `linear_references` value that contains an array of base64-encoded [OpenLR location references](https://www.openlr-association.com/fileadmin/user_upload/openlr-whitepaper_v1.5.pdf), one for each graph edge of the road network matched by the trace.
 */


data class MapMatchRequest (

    @Json(name = "costing")
    val costing: MapMatchCostingModel,

    /* An identifier to disambiguate requests (echoed by the server). */
    @Json(name = "id")
    val id: kotlin.String? = null,

    /* REQUIRED if `encoded_polyline` is not present. Note that `break` type locations are only supported when `shape_match` is set to `map_match`. */
    @Json(name = "shape")
    val shape: kotlin.collections.List<MapMatchWaypoint>? = null,

    /* REQUIRED if `shape` is not present. An encoded polyline (https://developers.google.com/maps/documentation/utilities/polylinealgorithm). Note that the polyline must be encoded with 6 digits of precision rather than the usual 5. */
    @Json(name = "encoded_polyline")
    val encodedPolyline: kotlin.String? = null,

    @Json(name = "costing_options")
    val costingOptions: CostingOptions? = null,

    /* Three snapping modes provide some control over how the map matching occurs. `edge_walk` is fast, but requires extremely precise data that matches the route graph almost perfectly. `map_snap` can handle significantly noisier data, but is very expensive. `walk_or_snap`, the default, tries to use edge walking first and falls back to map matching if edge walking fails. In general, you should not need to change this parameter unless you want to trace a multi-leg route with multiple `break` locations in the `shape`. */
    @Json(name = "shape_match")
    val shapeMatch: MapMatchRequest.ShapeMatch? = null,

    @Json(name = "directions_options")
    val directionsOptions: DirectionsOptions? = null,

    /* The timestamp at the start of the trace. Combined with `durations`, this provides a way to include timing information for an `encoded_polyline` trace. */
    @Json(name = "begin_time")
    val beginTime: kotlin.Int? = null,

    /* A list of durations (in seconds) between each successive pair of points in a polyline. */
    @Json(name = "durations")
    val durations: kotlin.Int? = null,

    /* If true, the input timestamps or durations should be used when computing elapsed time for each edge along the matched path rather than the routing algorithm estimates. */
    @Json(name = "use_timestamps")
    val useTimestamps: kotlin.Boolean? = false,

    @Json(name = "trace_options")
    val traceOptions: MapMatchTraceOptions? = null,

    /* If true, the response will include a `linear_references` value that contains an array of base64-encoded [OpenLR location references](https://www.openlr-association.com/fileadmin/user_upload/openlr-whitepaper_v1.5.pdf), one for each graph edge of the road network matched by the trace. */
    @Json(name = "linear_references")
    val linearReferences: kotlin.Boolean? = false

) {

    /**
     * Three snapping modes provide some control over how the map matching occurs. `edge_walk` is fast, but requires extremely precise data that matches the route graph almost perfectly. `map_snap` can handle significantly noisier data, but is very expensive. `walk_or_snap`, the default, tries to use edge walking first and falls back to map matching if edge walking fails. In general, you should not need to change this parameter unless you want to trace a multi-leg route with multiple `break` locations in the `shape`.
     *
     * Values: edgeWalk,mapSnap,walkOrSnap
     */
    @JsonClass(generateAdapter = false)
    enum class ShapeMatch(val value: kotlin.String) {
        @Json(name = "edge_walk") edgeWalk("edge_walk"),
        @Json(name = "map_snap") mapSnap("map_snap"),
        @Json(name = "walk_or_snap") walkOrSnap("walk_or_snap");
    }
}

