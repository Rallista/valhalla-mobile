//
// LocateDetailedEdge.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
    import AnyCodable
#endif

public struct LocateDetailedEdge: Codable, JSONEncodable, Hashable {
    public enum SacScale: String, Codable, CaseIterable {
        case _none = "none"
        case hiking
        case mountainHiking = "mountain hiking"
        case demandingMountainHiking = "demanding mountain hiking"
        case alpineHiking = "alpine hiking"
        case demandingAlpineHiking = "demanding alpine hiking"
        case difficultAlpineHiking = "difficult alpine hiking"
    }

    public enum CycleLane: String, Codable, CaseIterable {
        case _none = "none"
        case shared
        case dedicated
        case separated
    }

    /** Is there a sidewalk to the left of the edge? */
    public var sidewalkLeft: Bool?
    /** Is there a sidewalk to the right of the edge? */
    public var sidewalkRight: Bool?
    public var laneCount: Int?
    /** Is there a stop sign at end of the directed edge? */
    public var stopSign: Bool?
    public var sacScale: SacScale?
    /** Is there a yield sign at end of the directed edge? */
    public var yieldSign: Bool?
    /** Does the edge lead to a \"no-through\" region? */
    public var notThru: Bool?
    /** Is the edge info forward? If false, then reverse is implied. */
    public var forward: Bool?
    public var endNode: NodeId?
    /** Is the edge part of a truck route/network? */
    public var truckRoute: Bool?
    public var speeds: Speeds?
    /** Is the edge part of a bicycle network? */
    public var bikeNetwork: Bool?
    /** Is the edge part of a roundabout? */
    public var roundAbout: Bool?
    /** Is there a traffic signal at the end of the directed edge? */
    public var trafficSignal: Bool?
    /** Is there a general restriction or access condition? */
    public var accessRestriction: Bool?
    /** Is the edge destination only? If so, it will not be routed through. */
    public var destinationOnly: Bool?
    public var geoAttributes: GeoAttributes?
    public var startRestriction: Restrictions?
    /** Indication of the type of cycle lane (if any) present along an edge. */
    public var cycleLane: CycleLane?
    public var endRestriction: Restrictions?
    /** Is access seasonal (ex. no access in winter)? */
    public var seasonal: Bool?
    /** Does the edge cross into a new country? */
    public var countryCrossing: Bool?
    /** Is the edge part of a complex restriction? */
    public var partOfComplexRestriction: Bool?
    /** Do exit signs exist for the edge? */
    public var hasSign: Bool?
    public var access: Restrictions?
    /** Is the edge part of a bridge? */
    public var bridge: Bool?
    public var classification: HighwayClassification?
    /** Is the edge part of a toll road? */
    public var toll: Bool?
    /** Is the edge part of a tunnel? */
    public var tunnel: Bool?

    public init(sidewalkLeft: Bool? = nil, sidewalkRight: Bool? = nil, laneCount: Int? = nil, stopSign: Bool? = nil, sacScale: SacScale? = nil, yieldSign: Bool? = nil, notThru: Bool? = nil, forward: Bool? = nil, endNode: NodeId? = nil, truckRoute: Bool? = nil, speeds: Speeds? = nil, bikeNetwork: Bool? = nil, roundAbout: Bool? = nil, trafficSignal: Bool? = nil, accessRestriction: Bool? = nil, destinationOnly: Bool? = nil, geoAttributes: GeoAttributes? = nil, startRestriction: Restrictions? = nil, cycleLane: CycleLane? = nil, endRestriction: Restrictions? = nil, seasonal: Bool? = nil, countryCrossing: Bool? = nil, partOfComplexRestriction: Bool? = nil, hasSign: Bool? = nil, access: Restrictions? = nil, bridge: Bool? = nil, classification: HighwayClassification? = nil, toll: Bool? = nil, tunnel: Bool? = nil) {
        self.sidewalkLeft = sidewalkLeft
        self.sidewalkRight = sidewalkRight
        self.laneCount = laneCount
        self.stopSign = stopSign
        self.sacScale = sacScale
        self.yieldSign = yieldSign
        self.notThru = notThru
        self.forward = forward
        self.endNode = endNode
        self.truckRoute = truckRoute
        self.speeds = speeds
        self.bikeNetwork = bikeNetwork
        self.roundAbout = roundAbout
        self.trafficSignal = trafficSignal
        self.accessRestriction = accessRestriction
        self.destinationOnly = destinationOnly
        self.geoAttributes = geoAttributes
        self.startRestriction = startRestriction
        self.cycleLane = cycleLane
        self.endRestriction = endRestriction
        self.seasonal = seasonal
        self.countryCrossing = countryCrossing
        self.partOfComplexRestriction = partOfComplexRestriction
        self.hasSign = hasSign
        self.access = access
        self.bridge = bridge
        self.classification = classification
        self.toll = toll
        self.tunnel = tunnel
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case sidewalkLeft = "sidewalk_left"
        case sidewalkRight = "sidewalk_right"
        case laneCount = "lane_count"
        case stopSign = "stop_sign"
        case sacScale = "sac_scale"
        case yieldSign = "yield_sign"
        case notThru = "not_thru"
        case forward
        case endNode = "end_node"
        case truckRoute = "truck_route"
        case speeds
        case bikeNetwork = "bike_network"
        case roundAbout = "round_about"
        case trafficSignal = "traffic_signal"
        case accessRestriction = "access_restriction"
        case destinationOnly = "destination_only"
        case geoAttributes = "geo_attributes"
        case startRestriction = "start_restriction"
        case cycleLane = "cycle_lane"
        case endRestriction = "end_restriction"
        case seasonal
        case countryCrossing = "country_crossing"
        case partOfComplexRestriction = "part_of_complex_restriction"
        case hasSign = "has_sign"
        case access
        case bridge
        case classification
        case toll
        case tunnel
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(sidewalkLeft, forKey: .sidewalkLeft)
        try container.encodeIfPresent(sidewalkRight, forKey: .sidewalkRight)
        try container.encodeIfPresent(laneCount, forKey: .laneCount)
        try container.encodeIfPresent(stopSign, forKey: .stopSign)
        try container.encodeIfPresent(sacScale, forKey: .sacScale)
        try container.encodeIfPresent(yieldSign, forKey: .yieldSign)
        try container.encodeIfPresent(notThru, forKey: .notThru)
        try container.encodeIfPresent(forward, forKey: .forward)
        try container.encodeIfPresent(endNode, forKey: .endNode)
        try container.encodeIfPresent(truckRoute, forKey: .truckRoute)
        try container.encodeIfPresent(speeds, forKey: .speeds)
        try container.encodeIfPresent(bikeNetwork, forKey: .bikeNetwork)
        try container.encodeIfPresent(roundAbout, forKey: .roundAbout)
        try container.encodeIfPresent(trafficSignal, forKey: .trafficSignal)
        try container.encodeIfPresent(accessRestriction, forKey: .accessRestriction)
        try container.encodeIfPresent(destinationOnly, forKey: .destinationOnly)
        try container.encodeIfPresent(geoAttributes, forKey: .geoAttributes)
        try container.encodeIfPresent(startRestriction, forKey: .startRestriction)
        try container.encodeIfPresent(cycleLane, forKey: .cycleLane)
        try container.encodeIfPresent(endRestriction, forKey: .endRestriction)
        try container.encodeIfPresent(seasonal, forKey: .seasonal)
        try container.encodeIfPresent(countryCrossing, forKey: .countryCrossing)
        try container.encodeIfPresent(partOfComplexRestriction, forKey: .partOfComplexRestriction)
        try container.encodeIfPresent(hasSign, forKey: .hasSign)
        try container.encodeIfPresent(access, forKey: .access)
        try container.encodeIfPresent(bridge, forKey: .bridge)
        try container.encodeIfPresent(classification, forKey: .classification)
        try container.encodeIfPresent(toll, forKey: .toll)
        try container.encodeIfPresent(tunnel, forKey: .tunnel)
    }
}
