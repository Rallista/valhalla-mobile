//
// RoutingWaypoint.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
    import AnyCodable
#endif

public struct RoutingWaypoint: Codable, JSONEncodable, Hashable {
    public enum ModelType: String, Codable, CaseIterable {
        case _break = "break"
        case through
        case via
        case breakThrough = "break_through"
    }

    public enum PreferredSide: String, Codable, CaseIterable {
        case same
        case opposite
        case either
    }

    static let headingRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: 360, exclusiveMaximum: false, multipleOf: nil)
    static let headingToleranceRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: 360, exclusiveMaximum: false, multipleOf: nil)
    static let minimumReachabilityRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    static let radiusRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    static let nodeSnapToleranceRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    static let streetSideToleranceRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    static let streetSideMaxDistanceRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    /** The latitude of a point in the shape. */
    public var lat: Double
    /** The longitude of a point in the shape. */
    public var lon: Double
    /** A `break` represents the start or end of a leg, and allows reversals. A `through` location is an intermediate waypoint that must be visited between `break`s, but at which reversals are not allowed. A `via` is similar to a `through` except that reversals are allowed. A `break_through` is similar to a `break` in that it can be the start/end of a leg, but does not allow reversals. */
    public var type: ModelType? = ._break
    /** The preferred direction of travel when starting the route, in integer clockwise degrees from north. North is 0, south is 180, east is 90, and west is 270. */
    public var heading: Int?
    /** The tolerance (in degrees) determining whether a street is considered the same direction. */
    public var headingTolerance: Int? = 60
    /** The minimum number of nodes that must be reachable for a given edge to consider that edge as belonging to a connected region. If a candidate edge has fewer connections, it will be considered a disconnected island. */
    public var minimumReachability: Int? = 50
    /** The distance (in meters) to look for candidate edges around the location for purposes of snapping locations to the route graph. If there are no candidates within this distance, the closest candidate within a reasonable search distance will be used. This is subject to clamping by internal limits. */
    public var radius: Int? = 0
    /** If true, candidates will be ranked according to their distance from the target location as well as other factors. If false, candidates will only be ranked using their distance from the target. */
    public var rankCandidates: Bool? = true
    /** If the location is not offset from the road centerline or is closest to an intersection, this option has no effect. Otherwise, the preferred side of street is used to determine whether or not the location should be visited from the same, opposite or either side of the road with respect to the side of the road the given locale drives on. */
    public var preferredSide: PreferredSide?
    /** During edge correlation this is the tolerance (in meters) used to determine whether or not to snap to the intersection rather than along the street, if the snap location is within this distance from the intersection, the intersection is used instead. */
    public var nodeSnapTolerance: Int? = 5
    /** A tolerance in meters from the edge centerline used for determining the side of the street that the location is on. If the distance to the centerline is less than this tolerance, no side will be inferred. Otherwise, the left or right side will be selected depending on the direction of travel. */
    public var streetSideTolerance: Int? = 5
    /** A tolerance in meters from the edge centerline used for determining the side of the street that the location is on. If the distance to the centerline is greater than this tolerance, no side will be inferred. Otherwise, the left or right side will be selected depending on the direction of travel. */
    public var streetSideMaxDistance: Int? = 1000
    public var searchFilter: RoutingWaypointAllOfSearchFilter?

    public init(lat: Double, lon: Double, type: ModelType? = ._break, heading: Int? = nil, headingTolerance: Int? = 60, minimumReachability: Int? = 50, radius: Int? = 0, rankCandidates: Bool? = true, preferredSide: PreferredSide? = nil, nodeSnapTolerance: Int? = 5, streetSideTolerance: Int? = 5, streetSideMaxDistance: Int? = 1000, searchFilter: RoutingWaypointAllOfSearchFilter? = nil) {
        self.lat = lat
        self.lon = lon
        self.type = type
        self.heading = heading
        self.headingTolerance = headingTolerance
        self.minimumReachability = minimumReachability
        self.radius = radius
        self.rankCandidates = rankCandidates
        self.preferredSide = preferredSide
        self.nodeSnapTolerance = nodeSnapTolerance
        self.streetSideTolerance = streetSideTolerance
        self.streetSideMaxDistance = streetSideMaxDistance
        self.searchFilter = searchFilter
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case lat
        case lon
        case type
        case heading
        case headingTolerance = "heading_tolerance"
        case minimumReachability = "minimum_reachability"
        case radius
        case rankCandidates = "rank_candidates"
        case preferredSide = "preferred_side"
        case nodeSnapTolerance = "node_snap_tolerance"
        case streetSideTolerance = "street_side_tolerance"
        case streetSideMaxDistance = "street_side_max_distance"
        case searchFilter = "search_filter"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(lat, forKey: .lat)
        try container.encode(lon, forKey: .lon)
        try container.encodeIfPresent(type, forKey: .type)
        try container.encodeIfPresent(heading, forKey: .heading)
        try container.encodeIfPresent(headingTolerance, forKey: .headingTolerance)
        try container.encodeIfPresent(minimumReachability, forKey: .minimumReachability)
        try container.encodeIfPresent(radius, forKey: .radius)
        try container.encodeIfPresent(rankCandidates, forKey: .rankCandidates)
        try container.encodeIfPresent(preferredSide, forKey: .preferredSide)
        try container.encodeIfPresent(nodeSnapTolerance, forKey: .nodeSnapTolerance)
        try container.encodeIfPresent(streetSideTolerance, forKey: .streetSideTolerance)
        try container.encodeIfPresent(streetSideMaxDistance, forKey: .streetSideMaxDistance)
        try container.encodeIfPresent(searchFilter, forKey: .searchFilter)
    }
}
