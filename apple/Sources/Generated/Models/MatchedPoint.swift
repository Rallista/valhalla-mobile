//
// MatchedPoint.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
    import AnyCodable
#endif

public struct MatchedPoint: Codable, JSONEncodable, Hashable {
    public enum ModelType: String, Codable, CaseIterable {
        case unmatched
        case interpolated
        case matched
    }

    /** The latitude of the matched point. */
    public var lat: Double
    /** The longitude of the matched point. */
    public var lon: Double
    public var type: ModelType
    /** The index of the edge in the list of `edges`. This key will be missing if the point is unmatched. */
    public var edgeIndex: Int?
    /** If true, this match result is the begin location of a route discontinuity. */
    public var beginRouteDiscontinuity: Bool? = false
    /** If true, this match result is the end location of a route discontinuity. */
    public var endRouteDiscontinuity: Bool? = false
    /** The distance along the associated edge for this matched point, expressed as a value between 0 and 1. For example, if the matched point is halfway along the edge, then the value will be 0.5. This key will be absent if the point is unmatched. */
    public var distanceAlongEdge: Double?
    /** The distance in meters from the trace point to the matched point. This key will be absent if the point is unmatched. */
    public var distanceFromTracePoint: Double?

    public init(lat: Double, lon: Double, type: ModelType, edgeIndex: Int? = nil, beginRouteDiscontinuity: Bool? = false, endRouteDiscontinuity: Bool? = false, distanceAlongEdge: Double? = nil, distanceFromTracePoint: Double? = nil) {
        self.lat = lat
        self.lon = lon
        self.type = type
        self.edgeIndex = edgeIndex
        self.beginRouteDiscontinuity = beginRouteDiscontinuity
        self.endRouteDiscontinuity = endRouteDiscontinuity
        self.distanceAlongEdge = distanceAlongEdge
        self.distanceFromTracePoint = distanceFromTracePoint
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case lat
        case lon
        case type
        case edgeIndex = "edge_index"
        case beginRouteDiscontinuity = "begin_route_discontinuity"
        case endRouteDiscontinuity = "end_route_discontinuity"
        case distanceAlongEdge = "distance_along_edge"
        case distanceFromTracePoint = "distance_from_trace_point"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(lat, forKey: .lat)
        try container.encode(lon, forKey: .lon)
        try container.encode(type, forKey: .type)
        try container.encodeIfPresent(edgeIndex, forKey: .edgeIndex)
        try container.encodeIfPresent(beginRouteDiscontinuity, forKey: .beginRouteDiscontinuity)
        try container.encodeIfPresent(endRouteDiscontinuity, forKey: .endRouteDiscontinuity)
        try container.encodeIfPresent(distanceAlongEdge, forKey: .distanceAlongEdge)
        try container.encodeIfPresent(distanceFromTracePoint, forKey: .distanceFromTracePoint)
    }
}
