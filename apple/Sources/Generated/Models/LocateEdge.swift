//
// LocateEdge.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
    import AnyCodable
#endif

public struct LocateEdge: Codable, JSONEncodable, Hashable {
    public enum SideOfStreet: String, Codable, CaseIterable {
        case _left = "left"
        case _right = "right"
        case neither
    }

    public var edgeId: NodeId?
    public var correlatedLat: Double?
    public var correlatedLon: Double?
    public var percentAlong: Double?
    public var sideOfStreet: SideOfStreet?
    /** A base64-encoded [OpenLR location reference](https://www.openlr-association.com/fileadmin/user_upload/openlr-whitepaper_v1.5.pdf), for a graph edge of the road network matched by the query. */
    public var linearReference: String?
    public var outboundReach: Int?
    public var heading: Float?
    public var inboundReach: Int?
    public var distance: Float?
    /** Predicted speed information based on historical data. If available, this will include 2016 entries. Each entry represents 5 minutes, where the first entry represents midnight on Monday, the second entry represents 00:05 on Monday, etc. */
    public var predictedSpeeds: [Int]?
    public var edgeInfo: LocateEdgeInfo?
    public var edge: LocateDetailedEdge?
    public var warnings: [String]?

    public init(edgeId: NodeId? = nil, correlatedLat: Double? = nil, correlatedLon: Double? = nil, percentAlong: Double? = nil, sideOfStreet: SideOfStreet? = nil, linearReference: String? = nil, outboundReach: Int? = nil, heading: Float? = nil, inboundReach: Int? = nil, distance: Float? = nil, predictedSpeeds: [Int]? = nil, edgeInfo: LocateEdgeInfo? = nil, edge: LocateDetailedEdge? = nil, warnings: [String]? = nil) {
        self.edgeId = edgeId
        self.correlatedLat = correlatedLat
        self.correlatedLon = correlatedLon
        self.percentAlong = percentAlong
        self.sideOfStreet = sideOfStreet
        self.linearReference = linearReference
        self.outboundReach = outboundReach
        self.heading = heading
        self.inboundReach = inboundReach
        self.distance = distance
        self.predictedSpeeds = predictedSpeeds
        self.edgeInfo = edgeInfo
        self.edge = edge
        self.warnings = warnings
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case edgeId = "edge_id"
        case correlatedLat = "correlated_lat"
        case correlatedLon = "correlated_lon"
        case percentAlong = "percent_along"
        case sideOfStreet = "side_of_street"
        case linearReference = "linear_reference"
        case outboundReach = "outbound_reach"
        case heading
        case inboundReach = "inbound_reach"
        case distance
        case predictedSpeeds = "predicted_speeds"
        case edgeInfo = "edge_info"
        case edge
        case warnings
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(edgeId, forKey: .edgeId)
        try container.encodeIfPresent(correlatedLat, forKey: .correlatedLat)
        try container.encodeIfPresent(correlatedLon, forKey: .correlatedLon)
        try container.encodeIfPresent(percentAlong, forKey: .percentAlong)
        try container.encodeIfPresent(sideOfStreet, forKey: .sideOfStreet)
        try container.encodeIfPresent(linearReference, forKey: .linearReference)
        try container.encodeIfPresent(outboundReach, forKey: .outboundReach)
        try container.encodeIfPresent(heading, forKey: .heading)
        try container.encodeIfPresent(inboundReach, forKey: .inboundReach)
        try container.encodeIfPresent(distance, forKey: .distance)
        try container.encodeIfPresent(predictedSpeeds, forKey: .predictedSpeeds)
        try container.encodeIfPresent(edgeInfo, forKey: .edgeInfo)
        try container.encodeIfPresent(edge, forKey: .edge)
        try container.encodeIfPresent(warnings, forKey: .warnings)
    }
}
